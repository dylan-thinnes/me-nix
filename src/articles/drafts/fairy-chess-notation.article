Fairy Chess: A New Notation
Dylan Thinnes
I've invented yet another chess notation system. Here's a breakdown.

## What's Fairy Chess?

"Fairy chess" is a general term for chess pieces and variants that expand
beyond the conventional chess set and layout. It is sometimes even used for
games like *shogi* that significantly predate modern chess.

### Notation Systems

Of course, with the growth of fairy chess as a concept, people wanted to
standardize a notation to express different pieces, so that pieces could be
clearly tabulated, shared, and possibly even simulated.

Some examples of fairy chess notations are [Betza's funny
notation](https://www.gnu.org/software/xboard/Betza.html) and [Parlett's
notation](https://en.wikipedia.org/wiki/Fairy_chess_piece#Parlett's_movement_notation).

### A Notation All My Own

After looking at some of these notation systems, I found each of them somewhat
lacking in different ways. After putting it down in words, I found three
principles I wanted to strive for:

- Each move is a value that is modified by operators as in a regular
  programming language.
- Compact, regex-like syntax.
- Fits complex concepts such as castling and en-passant into the system without
  requiring very specific operators.
- Decent mathematical underpinnings.

## Dylan's Boring Notation

In the vein of Betza's Funny Notation, I decided to call my notation Dylan's
Boring Notation.

What's important to understand is that every item in Boring Notation is
actually a "moveset", a collection of distinct moves.

### Atoms

The most basic moveset in Boring Notation is the `atom` (a term borrowed from
Betza's), which contains just a single move going in a static x and y
direction. It is written as such:

```
[x,y]
```

Where x and y can be positive or negative integers. Examples:

- `[1,2]` would be a piece that can only move 1 tile to the right and 2 tiles
  upwards.

- `[3,3]` would be a piece that can only move 3 tiles to the right and 3 tiles
  upwards.

### Addition

Movesets can be added together using the "addition operator", `,`. When you
**add** two movesets together, you end up with a moveset that contains all the
moves in the first and all the moves in the second. A piece with that moveset
thus can make either a move in the first set, or a move in the second.

Examples:

- `[1,2],[2,1]` would be a piece that can **EITHER:**
  - move 1 right and 2 up **OR**
  - move 2 right and 1 up.
- `[1,2],[2,1],[3,3]` would be a piece that can **EITHER:**
  - move 1 right and 2 up **OR**
  - move 2 right and 1 up **OR**
  - move 3 right and 3 up.

### Multiplication

Movesets can be "multiplied" using `A.B`. In the case of multiplication, all
possible moves from both movesets become possible, *in sequence*. 

For example, `[1,2].[2,1]` denotes a piece capable of a `[3,3]` move by jumping
to `[1,2]` then to `[2,1]`. As in normal chess, if the `[1,2]` position is
blocked, it would therefore not be possible to proceed to `[2,1],` so the
`[3,3]` jump would become illegal.

The multiplication operator `.` binds more tightly than the addition operator
`,`, so `[1,2].[3,3],[2,2].[4,5]` would be equivalent to
`([1,2].[3,3]),([2,2].[4,5])`.

### Multiplication tries all combinations

An important thing to remember about multiplication is it tries all
combinations of moves in each moveset. So, if you have two movesets
`[2,0],[0,2]` (`[2,0]` OR `[2,0]`) and `[1,2],[-1,-2]` (`[1,2]` OR `[-1,-2]`),
their multiplication would be broken down as follows:

```
([2,0],[0,2]).([1,2],[-1,-2])
([2,0].[1,2]) , ([0,2].[1,2]) , ([2,0].[-1,-2]) , ([0,2].[-1,-2])
```

## Moveset Modifiers

Each moveset can be modified by appending modifiers, some of which are listed as follows:

### Mirror, mirror, on the wall...

### `|`

  Reflects a moveset **across** the y-axis (along the x-axis)  
  e.g. `[1,2]|` would mean a piece that can move `[1,2]` or `[-1,2]`

  ![](doc/images/./[1,2].png) => ![](doc/images/./[1,2]|.png)

### `-`

  Reflects a moveset **across** the x-axis (along the y-axis)  
  e.g. `[1,2]-` would mean a piece that can move `[1,2]` or `[1,-2]`

  ![](doc/images/./[1,2].png) => ![](doc/images/./[1,2]-.png)

### `+`

  Does both x and y mirrors  
  e.g. `[1,2]+` becomes `[1,2]` or `[1,-2]` or `[-1,2]` or `[-1,-2]`

  ![](doc/images/./[1,2].png) => ![](doc/images/./[1,2]+.png)

### `/` 

  Swaps the x and y axes  
  e.g. `[1,2]/` becomes `[1,2]` or `[2,1]`

  ![](doc/images/./[1,2].png) => ![](doc/images/./[1,2]SLASH.png)

### `*`

  Combines x mirror, y mirror, and swap  
  e.g. `[1,2]*` becomes `[1,2]` or `[1,-2]` or `[-1,2]` or `[-1,-2]` or `[2,1]` or `[2,-1]` or `[-2,1]` or `[-2,-1]`

  ![](doc/images/./[1,2].png) => ![](doc/images/./[1,2]*.png)

### Containing multitudes...

In order to multiply a moveset with itself, use the **mapped multiplication**
modifier, written as `{a..b}` or `{c}`.

The ranges can be combined with `,` so one can write
```
{2..3,5,7..9}
```
which would be equivalent to
```
{2,3,5,7,8,9}
```

This multiplies each move in a moveset by itself by the number of times for
each value in the range, and then sums those multiplied movesets.

#### Examples

`[1,2]{1} = [1,2]`

![](doc/images/[1,2].png)
=> {1} =>
![](doc/images/[1,2]{1}.png)

#### `[1,2]{2}`

`[1,2]{2} = [1,2].[1,2]`

![](doc/images/[1,2].png)
=> {2} =>
![](doc/images/[1,2]{2}.png)

#### `[1,2]{3}`

`[1,2]{3} = [1,2].[1,2].[1,2]`

![](doc/images/[1,2].png)
=> {3} =>
![](doc/images/[1,2]{3}.png)

#### `[1,2]{1..3}`

![](doc/images/[1,2].png)
=> {1..3} =>
![](doc/images/[1,2]{1,2,3}.png)

#### `[1,2]{2,3}`

![](doc/images/[1,2].png)
=> {2,3} =>
![](doc/images/[1,2]{2,3}.png)

#### `([1,2],[2,1]){2}`

`([1,2],[2,1]){2} = ([1,2].[1,2]),([2,1].[2,1])`

![](doc/images/./[1,2],[2,1].png)
=> {2} =>
![](doc/images/%28[1,2],[2,1]%29{2}.png)

#### `([1,2],[2,1]){1..3}`

`([1,2],[2,1]){1..3} = ([1,2]),([1,2].[1,2]),([1,2].[1,2].[1,2]),([2,1]),([2,1].[2,1]),([2,1].[2,1].[2,1])`

![](doc/images/./[1,2],[2,1].png)
=> {1..3} =>
![](doc/images/%28[1,2],[2,1]%29{1..3}.png)

#### Multiplication vs mapped multiplication

Mapped multiplication is *not* the equivalent of running multiplication n
times. Put in notation:

```
([1,2],[2,1]){3} =/= ([1,2],[2,1]).([1,2],[2,1]).([1,2],[2,1])
```

The mapped multiplication runs the multiplication over each individual move.
Put in notation:

```
([1,2],[2,1]){3} =/= ([1,2]{3},[2,1]{3})
```

For an operator that works more like the first example, look at
[Exponentiation](#exponentiation).

#### Omitting bounds

The bounds on a `..` can be omitted, in which case they'll default to 1 for the
left and infinity for the right.

```
{..4} = {1..4} = {1,2,3,4}
{2..} = {2,3,4,5,6,7...}
{..}  = {1,2,3,4,5,6,7...}
```

#### Useful examples

This is useful for expressing pieces that make multiple of the same small step
as long as possible, e.g. bishop and rook

A rook could be `[0,1]{1..}*`

![](doc/images/[1,0]{1..4}*.png)

A bishop could be `([1,1]){1..}*`

![](doc/images/[1,1]{1..4}*.png)

A queen could be `[0,1]{1..}*,[1,1]{1..}*`

![](doc/images/[0,1]{1..4}*,[1,1]{1..4}*.png)

### Exponentiation

This multiplies each an **entire moveset** by itself by the number of times for
each value in the range, and then sums those multiplied movesets.

While the `{}` operator runs on each move individually, this operator, `{{}}`
actually multiplies movesets using `.` repeatedly. This may be a hard
distinction to grasp - let's look at a few examples.

#### `([1,2],[2,1]){{2}}`

`([1,2],[2,1]){{2}} = ([1,2],[2,1]).([1,2],[2,1]) = ([1,2].[1,2]),([1,2].[2,1]),([2,1].[1,2]),([1,2].[1,2])`

![](doc/images/./[1,2],[2,1].png)
=> `{{2}}` =>
![](doc/images/%28[1,2],[2,1]%29{{2}}.png)

#### `([1,2],[2,1])|{{2}}`

![](doc/images/./[1,2],[2,1].png)
=> `|` =>
![](doc/images/./%28[1,2],[2,1]%29|.png)
=> `{{2}}` =>
![](doc/images/%28[1,2],[2,1]%29|{{2}}.png)

#### `([1,2],[2,1]){{2}}|`

![](doc/images/./[1,2],[2,1].png)
=> `{{2}}` =>
![](doc/images/./%28[1,2],[2,1]%29{{2}}.png)
=> `|` =>
![](doc/images/%28[1,2],[2,1]%29{{2}}|.png)

Notice how the order of modifiers here, `|` and `{{2}}`, affect the result.
This is the case anywhere you use mirrors and then the `{{}}` operator. This is
not the case for mirorrs and `{}`, where the order does not affect the end
result.
